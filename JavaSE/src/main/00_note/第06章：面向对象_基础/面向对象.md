# 1. 类的成员

## 1.1. 类的成员之一：成员变量（field）

### 1.1.1. 简介

* **格式**

  ```java
  [修饰符 1] class 类名{
   [修饰符 2] 数据类型 成员变量名 [= 初始化值];
  }
  ```

* **总结**

  *  位置要求
    
    * 必须在类中，方法外
  * 修饰符  
    * 常用的权限修饰符有：private、缺省、protected、public
  * 其他修饰符：static、final 
  
* 数据类型
  
  * 任何基本数据类型(如 int、Boolean) 或 任何引用数据类型
  
* 成员变量名
  
  * 属于标识符，符合命名规则和规范即可
  
* 初始化值
  
  * 根据情况，可以显式赋值；也可以不赋值，使用默认值
  
      

### 1.1.2. 变量的分类

![图片](https://dawn1314.oss-cn-beijing.aliyuncs.com/typoraimg/202311161551578.png)

* 简介

  * 成员变量: 在方法体外，类体内声明的变量称为成员变量
  * 局部变量: 在方法体内部等位置声明的变量称为局部变量

  > static 可以将成员变量分为两大类，静态变量和非静态变量。其中静态变量又称为类变量，非静态变量又称为实例变量或者属性。

* 相同点
  * 变量声明的格式相同： 数据类型 变量名 = 初始化值
  * 变量必须先声明、后初始化、再使用
  * 变量都有其对应的作用域。只在其作用域内是有效的
* 不同点
  * 声明位置和方式 
    * 实例变量：在类中方法外 
    * 局部变量：在方法体{}中或方法的形参列表、代码块中
  * 在内存中存储的位置不同
    * 实例变量：堆
    * 局部变量：栈
  * 生命周期
    * 实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被 GC 回收而消亡， 而且每一个对象的实例变量是独立的
    * 实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被 GC 回收而消亡， 而且每一个对象的实例变量是独立的
  * 作用域 
    * 实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量” 
    * 局部变量：出了作用域就不能使用
  * 修饰符
    * 实例变量: public,protected,private,final,volatile,transient 等
    * 局部变量：final
  * 默认值
    * 实例变量：有默认值
    * 局部变量：没有，必须手动初始化。其中的形参比较特殊，靠实参给它初始化



## 1.2. 类的成员之二：方法（method）

### 1.2.1. 形参和实参 

* 形参（formal parameter）：在定义方法时，方法名后面括号()中声明的变量称为形式参数，简称形参
* 实参（actual parameter）：在调用方法时，方法名后面括号()中的使用的值/变量/表达式称为实际参数，简称实参



### 1.2.2. 参数传递机制：值传递

* Java 里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响

* 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参

* 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参



## 1.3. 类的成员之三：构造器（constructor）

* **格式**

  ```java
  [修饰符] class 类名{
   [修饰符] 构造器名(){
   // 实例初始化代码
   }
   [修饰符] 构造器名(参数列表){
   // 实例初始化代码
   }
  }
  ```

* **总结**
  *  构造器名必须与它所在的类名必须相同
  * 它没有返回值，所以不需要返回值类型，也不需要 void
  * 构造器的修饰符只能是权限修饰符，不能被其他任何修饰。比如，不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值。



## 1.4. 类的成员之四：代码块

* **简介**

  * **作用**

    * 对Java类或对象进行初始化

  * **分类**

    *  一个类中代码块若有修饰符，则只能被 static 修饰，称为静态代码块(static block) 
    * 没有使用 static 修饰的，为非静态代码块

  * **场景**

    如果成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值，该怎么办呢？此时，可以考虑代码块（或初始化块）

* **静态代码块**

  * **作用**

    * 如果想要为静态变量初始化，可以直接在静态变量的声明后面直接赋值，也可以使用静态代码块

  * **语法格式**

    ```java
    [修饰符] class 类 {
        static {
            静态代码块
        }
    }
    ```

  * **总结**
    * 可以有输出语句 
    * 可以对类的属性、类的声明进行初始化操作 
    * 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法
    * 若有多个静态的代码块，那么按照从上到下的顺序依次执行
    * 静态代码块的执行要先于非静态代码块 
    * 静态代码块随着类的加载而加载，且只执行一次

* **非静态代码块**

  * **作用**

    * 和构造器一样，也是用于实例变量的初始化等操作

    * 如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执

      行的，那么可以将这部分代码抽取到非静态代码块中，减少冗余代码。

  * **格式**

    ```java
    [修饰符] class 类{
     	{
     		非静态代码块
     	}
     [修饰符] 构造器名(){
     	// 实例初始化代码
     }
     [修饰符] 构造器名(参数列表){
     	// 实例初始化代码
     }
    }
    ```

  * **总结**
    * 可以有输出语句
    * 可以对类的属性、类的声明进行初始化操作
    * 除了调用非静态的结构外，还可以调用静态的变量或方法
    * 若有多个非静态的代码块，那么按照从上到下的顺序依次执行
    * 每次创建对象的时候，都会执行一次。且先于构造器执行

* **实例变量赋值顺序**

  1. 默认初始化
  2. 显示初始化, 多个初始化块依次被执行(同级别下按先后顺序执行)
  3. 构造器初始化
  4. "对象.属性"或"对象.方法"(这种方式可多次给属性赋值)

  

# 2. 面向对象特征

## 2.1. 面向对象特征一: 封装性(encapsulation)

|  修饰符   | 本类内部 | 本包内 | 其他包的子类 | 其他包的非子类 |
| :-------: | :------: | :----: | :----------: | :------------: |
|  private  |    √     |   ×    |      ×       |       ×        |
|   缺省    |    √     |   √    |      ×       |       ×        |
| protected |    √     |   √    |      √       |       ×        |
|  public   |    √     |   √    |      √       |       √        |



## 2.2. **面向对象特征二：继承(Inheritance)** 

* 简介

  * 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类中无需再定义这些属性和行为，只需要和抽取出来的类构成继承关系

* 优点

  * 继承的出现减少了代码冗余，提高了代码的复用性

  * 继承的出现，更有利于功能的扩展 

  * 继承的出现让类与类之间产生了 `is-a` 的关系，为多态的使用提供了前提

  * 继承描述事物之间的所属关系，这种关系是：is-a 的关系。可见，父类

    更通用、更一般，子类更具体

* 语法格式

  通过 `extends `关键字，可以声明一个类 B 继承另外一个类 A，定义格式如下

  ```java
  [修饰符] class 类 A {
  ...
  }
  [修饰符] class 类 B extends 类 A {
  ...
  }
  ```

* 基本概念

  * 类 B，称为子类、派生类(derived class)、SubClass
  * 类 A，称为父类、超类、基类(base class)、SuperClass

* 总结

  * **子类会继承父类所有的实例变量和实例方法**

    从类的定义来看，类是一类具有相同特性的事物的抽象描述。父类是所有子类共同特征的抽象描述。而实例变量和实例方法就是事物的特征，那么父类中声明的实例变量和实例方法代表子类事物也有这个特征

  * **子类不能直接访问父类中私有的(private)的成员变量和方法**

    子类虽会继承父类私有(private)的成员变量，但子类不能对继承的私有成员变量直接进行访问，可通过继承的 get/set 方法进行访问

  * **在 Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展**

    子类在继承父类以后，还可以定义自己特有的方法，这就可以看做是对父类功能上的扩展

  * **所有的类默认继承 Object，作为父类**
  
  * **一个父类可以同时拥有多个子类**

  * **Java 只支持单继承，不支持多重继承**
  
  

## 2.3. **面向对象特征二：多态** 

* **简介**

  多态性，是面向对象中最重要的概念，在 Java 中的体现：对象的多态性：父类的引用指向子类的对象

* **语法**

  父类类型 变量名 = 子类对象；(父类类型：指子类继承的父类类型，或者实现的接口类型)

* **类型转换**

  * 向上转型

    * 简介

      当左边的变量的类型（父类） > 右边对象/变量的类型（子类），我们就称为向上转型, 即多态的表现

    * 总结

      * 此时，编译时按照左边变量的类型处理，就只能调用父类中有的变量和方法，不能调用子类特有的变量和方法了
      * 但是，**运行时，仍然是对象本身的类型**，所以执行的方法是子类重写的方法体
      * 此时，一定是安全的，而且也是自动完成的

  * 向下转型

    * 简介

      当左边的变量的类型（子类）<右边对象/变量的编译时类型（父类），我们就称为向下转型

    * 总结
      * 此时，编译时按照左边变量的类型处理，就可以调用子类特有的变量和方法了
      * 但是，**运行时，仍然是对象本身的类型** 
      * 不是所有通过编译的向下转型都是正确的，可能会发生ClassCastException，为了安全，可以通过 isInstanceof 关键字进行判断

    

* 总结

  * **成员变量没有多态性**

    * 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中
    * 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量

    



# 3. 关键字

## 3.1. 关键字: package

* **简介**
  * package，称为包，用于指明该文件中定义的类、接口等结构所在的包

* **总结**
  * 一个源文件只能有一个声明包的 package 语句
  * package 语句作为 Java 源文件的第一条语句出现。若缺省该语句，则指定为无名包 
  * 包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意
    * 包通常使用所在公司域名的倒置：com.atguigu.xxx。
    * 大家取包名时不要使用"*java.xx*"包
    * 包对应于文件系统的目录，package 语句中用 “.” 来指明包(目录)的层次，每"."一次就表示一层文件目录。
    * 同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）
    * 不同的包下可以定义同名的结构（类、接口）



## 3.2. 关键字: import

* **简介**
  
* 为了使用定义在其它包中的 Java 类，需用 import 语句来显式引入指定包下所需要的类。相当于 import 语句告诉编译器到哪里去寻找这个类
  
* 总结

  * import 语句，声明在包的声明和类的声明之间

  * 如果需要导入多个类或接口，那么就并列显式多个 import 语句即可 

  * 如果使用 `*a.**`导入结构，表示可以导入 a 包下的所有的结构。举例：可以使用

    java.util.*的方式，一次性导入 util 包下所有的类或接口

  * **如果导入的类或接口是 java.lang 包下的，或者是当前包下的，则可以省略此 import语句**

  * 如果已经导入 java.a 包下的类，那么如果需要使用 a 包的子包下的类的话，仍然需要

    导入

  * 如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。

  * `import static` 组合的使用：调用指定类或接口下的静态的属性或方法



## 3.2. 关键字: this

### 3.2.1. 简介

* 它在方法（准确的说是实例方法或非 static 的方法）内部使用，表示调用该方法的对象

* 它在构造器内部使用，表示该构造器正在初始化的对象

* this 可以调用的结构：成员变量、方法和构造器

  

### 3.2.1. 使用

* **实例方法或构造器中使用当前对象的成员**
  * 在实例方法或构造器中，如果使用当前类的成员变量或成员方法可以在其前面添加 this，增强程序的可读性。不过，通常我们都习惯省略 this
  
  * 但是，当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加 this 来表明该变量是类的成员变量。即：我们可以用 this 来区分成员变量和局部变量. 
  
  * 使用 this 访问属性和方法时，如果在本类中未找到，会从父类中查找
  
* **同一个类中构造器中互相调用**

  * 方式
    * **`this()`**：调用本类的无参构造器
    * **`this(实参列表)`**：调用本类的有参构造器
  * 总结
    * 不能出现递归调用。比如，调用自身构造器. 即**如果一个类中声明了 n 个构造器，则最多有 n - 1 个构造器中使用了"this(形参列表)"**
    * this()和 this(实参列表)只能声明在构造器首行. 即, **在类的一个构造器中，最多只能声明一个"this(参数列表)"**

  ```java
  public class Student {
      private String name;
      private int age;
      // 无参构造
      public Student() {
        // this("",18);//调用本类有参构造器
      }
      
      // 有参构造
      public Student(String name) {
          this();//调用本类无参构造器
          this.name = name;
      }
      
      // 有参构造
      public Student(String name,int age){
          this(name);//调用本类中有一个 String 参数的构造器
          this.age = age;
      }
      public String getName() {
          return name;
      }
      public void setName(String name) {
          this.name = name;
      }
      public int getAge() {
          return age;
      }
      public void setAge(int age) {
          this.age = age;
      }
      public String getInfo(){
          return "姓名：" + name +"，年龄：" + age;
      }
  }
  ```




## 3.3. 关键字: super

### 3.3.1. 简介

* **在 Java 类中使用 super 来调用父类中的指定操作**
  * super 可用于访问父类中定义的属性
  * super 可用于调用父类中定义的成员方法
  * super 可用于在子类构造器中调用父类的构造器

* **总结**

  * 尤其当子父类出现同名成员时，可以用 super 表明调用的是父类中的成员
  * super 的追溯不仅限于直接父类 
  * super 和 this 的用法相像，this 代表本类对象的引用，super 代表父类的内存空间的标识

  

### 3.3.2. 使用

* **子类中调用父类被重写的方法** 

  * **简介**
    * 如果子类没有重写父类的方法，只要权限修饰符允许，在子类中完全可以直接调用父类的方法
    * 如果子类重写了父类的方法，在子类中需要通过 **`super.`**才能调用父类被重写的方法，否则默认调用的子类重写的方法

  * **总结**

    * **方法前面没有 super.和 this.**

      先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯

    * **方法前面有 this.**

      先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯

    * **方法前面有 super.**

      从当前子类的直接父类找，如果没有，继续往上追溯

* **子类中调用父类中同名的成员变量** 

  * 简介
    * 如果实例变量与局部变量重名，可以在实例变量前面加 this.进行区别
    * 如果子类实例变量和父类实例变量重名，并且父类的该实例变量在子类仍然可见，在子类中要访问父类声明的实例变量需要在父类实例变量前**`super.`**，否则默认访问的是子类自己声明的实例变量
    * 如果父子类实例变量没有重名，只要权限修饰符允许，在子类中完全可以直接访问父类中声明的实例变量，也可以用 this.实例访问，也可以用 super.实例变量访问
  * 总结
    * **变量前面没有` super.`和 `this.`**
      * 在构造器、代码块、方法中如果出现使用某个变量，先查看是否是当前块声明的局部变量
      * 如果不是局部变量，先从当前执行代码的本类去找成员变量
      * 如果从当前执行代码的本类中没有找到，会往上找父类声明的成员变量（权限修饰符允许在子类中访问的）
    * **变量前面有` this.`**
      * 通过 this 找成员变量时，先从当前执行代码的本类去找成员变量
      * 如果从当前执行代码的本类中没有找到，会往上找父类声明的成员变量（权限修饰符允许在子类中访问的）
    * **变量前面 `super.`**
      * 通过 super 找成员变量，直接从当前执行代码的直接父类去找成员变量（权限修饰符允许在子类中访问的）
      * 如果直接父类没有，就去父类的父类中找（权限修饰符允许在子类中访问的）

* **子类中调用父类中同名的成员变量** 

  * 简介
    * 子类继承父类时，不会继承父类的构造器。只能通过**`super(形参列表)`**的方式调用父类指定的构造器
    * 子类继承父类时，不会继承父类的构造器。只能通过**`super(形参列表)`**的方式调用父类指定的构造器
    * 子类继承父类时，不会继承父类的构造器。只能通过**`super(形参列表)`**的方式调用父类指定的构造器
    * 子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。 只能是这两种情况之一
    * 一个类中声明有 n 个构造器，最多有 n-1 个构造器中使用了**`this(形参列表)`**，则剩下的那个一定使用**`super(形参列表)`**

  * 总结

    * 开发中常见错误

      * 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则编译出错

        

### 3.3.3. this和super的区别

* **this 和 super 的意义**

  * this：当前对象
    * 在构造器和非静态代码块中，表示正在 new 的对
    * 在实例方法中，表示调用当前方法的对象

  * super：引用父类声明的成员

* **this 和 super 的使用格式**

  * this
    * **`this.成员变量`**：表示当前对象的某个成员变量，而不是局部变量
    * **`this.成员方法`**：表示当前对象的某个成员方法，完全可以省略 this.
    * **`this()或 this(实参列表)`**：调用另一个构造器协助当前对象的实例化，只能在构造器首行，只会找本类的构造器，找不到就报错
  * super
    * **`super.成员变量`**：表示当前对象的某个成员变量，该成员变量在父类中声明的
    * **`super.成员方法`**：表示当前对象的某个成员方法，该成员方法在父类中声明的
    * **`super()或 super(实参列表)`**：调用父类的构造器协助当前对象的实例化，只能在构造器首行，只会找直接父类的对应构造器，找不到就报错



## 3.4. 关键字: instance

* 格式

  对象 a **instanceof** 数据类型 A  // 检验对象a 是否是数据类型 A 的对象，返回值为boolean 型

* 总结

  * 只要用 instanceof 判断返回 true 的，那么强转为该类型就一定是安全的，

    不会报 ClassCastException 异常 

  * 如果对象 a 属于类 A 的子类 B，a instanceof A 值也为 true
  * 要求对象 a 所属的类与类 A 必须是子类和父类的关系，否则编译错误。

* 示例

  ```java
  public class TestInstanceof {
       public static void main(String[] args) {
       Pet[] pets = new Pet[2];
       pets[0] = new Dog();//多态引用
       pets[0].setNickname("小白");
       pets[1] = new Cat();//多态引用
       pets[1].setNickname("雪球");
       for (int i = 0; i < pets.length; i++) {
      	 pets[i].eat();
           if(pets[i] instanceof Dog){
           	Dog dog = (Dog) pets[i];
           	dog.watchHouse();
           }else if(pets[i] instanceof Cat){
       		Cat cat = (Cat) pets[i];
      		cat.catchMouse();
   		}
   	}
  }
  ```



## 3.5. 关键字: native

* **简介**

  * 使用 native 关键字说明这个方法是原生函数，也就是这个方法是用 C/C++等非

    Java 语言实现的，并且被编译成了 DLL，由 Java 去调用

  * 本地方法是有方法体的，用 c 语言编写。由于本地方法的方法体源码没有对我们开

    源，所以我们看不到方法体

  * 在 Java 中定义一个 native 方法时，并不提供实现体

* **总结**

  * **使用用 native 方法的原因**

    va 使用起来非常方便，然而有些层次的任务用 java 实现起来不容易，或者我

    们对程序的效率很在意时，例如：Java 需要与一些底层操作系统或某些硬件交

    换信息时的情况。native 方法正是这样一种交流机制：它为我们提供了一个非

    常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节\

  *  **native 声明的方法，对于调用者，可以当做和其他 Java 方法一样使用**

    native method 的存在并不会对其他类调用这些本地方法产生任何影响，实际上

    调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM 将控制调

    用本地方法的所有细节



## 3.6. 关键字: static

* **简介**

  * **使用范围**
    * 在Java类中, 可用static修饰属性, 方法, 代码块和内部类
  * **特点总结**
    * 随着类的加载而加载
    * 优先于对象存在
    * 修饰的成员被所有的对象所共享
    * 访问权限允许时, 可不创建对象, 直接被类调用

* **静态变量**

  * **语法格式**

    ```java
    [修饰符] class 类名 {
        [其他修饰符] static 数据类型 变量名;
    }
    ```

  * **特点总结**
    * 静态变量的默认值规则和实例变量一样
    * 静态变量值是所有对象共享
    * 静态变量在本类中, 可以在任意方法, 代码块以及构造器中直接使用
    * 如果权限修饰允许, 在其他类中可以通过"类名.静态变量"直接访问, 也可以通过"对象.静态变量"的方式访问(推荐使用类名.静态变量的方式)
    * 静态变量的get/set方法也是静态的, 当静态变量与局部变量重名时, 使用**类名.静态变量**进行区分

* **静态方法**

  * **语法格式**

    ```java
    [修饰符] class 类名 {
        [其他修饰符] static 返回值类 方法名(形参列表) {
            方法体
        }
    }
    ```

  * **特点总结**
    * **静态方法的调用都只看编译时类型**
    * **静态方法可以被子类继承, 但不能被子类重写**
    * 静态方法在本类中的任意方法, 代码块, 构造器中都可以直接被调用
    * 在static方法内部只能访问类的static修饰的属性或方法, 不能访问类的非static的结构
    * 因为不需要实例就可以访问static, 因此static方法内部不能有this, 也不能有super. 如果有重名问题, 使用"类名."进行区别
    * 只要权限修饰符允许, 静态方在其他类中可以通过"类名.静态方法"的方式调用, 也可以通过"对象.静态方法"的方式调用(推荐使用**类名.静态方法**的方式)



# 4. 匿名对象

* **简介**
  * 我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象

* **总结**
  * 如果一个对象只需要进行一次方法调用，那么就可以使用匿名对象
  * 我们经常将匿名对象作为实参传递给一个方法调用



# 5. 赋值过程

* **(1) **默认初始化 **-->** **(2)** 显式初始化 **-->** **(3)** 构造器中初始化 **-->** **(4) **通过"对象.属性"或"对象.方法"的方式，给属性赋值



# 6. 方法的重写

* 简介

  子类可以对从父类中继承来的方法进行改造，我们称为方法的重写* (override、overwrite)。也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法

* 要求

  * 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表

  * 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。（例如：Student < Person）

     注意：如果返回值类型是基本数据类型和 void，那么必须是相同

  * 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限。（public > protected > 缺省 > private）

    注意：① 父类私有方法不能重写 ② 跨包的父类缺省的方法也不能重写 

  * 子类方法抛出的异常不能大于父类被重写方法的异常
  * 子类与父类中同名同参数的方法必须同时声明为非 static 的(即为重写)，或者同时声明为 static 的（不是重写）。因为 static 方法是属于类的，子类无法覆盖父类的方法



# 7. Object 类的使用

* 简介

  类 java.lang.Object 是类层次结构的根类，即所有其它类的父类。每个类都使用 Object 作为超类

* 方法

  * **`equals()`**

    * 简介

      * 基本类型比较值:只要两个变量的值相等，即为 true

      * 引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，才返回 true

    * 重写 equals()方法的原则

      * 对称性：

        如果 `x.equals(y)`返回是`true`，那么 `y.equals(x)`也应该返回是`true`

        自反性：`x.equals(x)`必须返回是`true` 

      * 传递性：如果 `x.equals(y)`返回是`true`，而且 `y.equals(z)`返回是`true`，那么`z.equals(x)`也应该返回是`true`
      * 一致性：如果 `x.equals(y)`返回是`true`，只要 x 和 y 内容一直不变，不管你重复 `x.equals(y)`多少次，返回都是`true`
      * 任何情况下，`x.equals(null)`，永远返回是`false`
      * `x.equals`(和 x 不同类型的对象)永远返回是`false`

    * 总结

      * 当用 equals()方法进行比较时，对类 File、String、Date 及包装类（Wrapper 

        Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象.原因是在这些类中重写了 Object 类的 equals()方法

      * 当自定义使用 equals()时，可以重写。用于比较两个对象的“内容”是否都相等

  * **`toString()`** 

    * 默认情况下，toString()返回的是“**对象的运行时类型@对象的 hashCode 值的十六进制形式**"

    * 在进行 String 与其它类型数据的连接操作时，自动调用 toString()方法

      ```java
      Date now=new Date();
      System.out.println(“now=”+now); //相当于下面的代码
      System.out.println(“now=”+now.toString());
      ```

    * 如果我们直接 System.out.println(对象)，默认会自动调用这个对象的

      toString(). 因为 Java 的引用数据类型的变量中存储的实际上时对象的内存地址，

      但是 Java 对程序员隐藏内存地址信息，所以不能直接将内存地址显示

      出来，所以当你打印对象时，JVM 帮你调用了对象的 toString()

    * 可以根据需要在用户自定义类型中重写 toString()方法 如 String 类重写了

      toString()方法，返回字符串的值

  * **getClass()**

    * `public final Class<?> getClass()`：获取对象的运行时类型

    * 因为 Java 有多态现象，所以一个引用数据类型的变量的编译时类型与

      运行时类型可能不一致，因此如果需要查看这个变量实际指向的对象

      的类型，需要用 getClass()方法	

    ```java
    public static void main(String[] args) {
    Object obj = new Person();
    System.out.println(obj.getClass());//运行时类型
    }
    
    // output
    class com.atguigu.java.Person
    ```

  * **hashCode()** 	
  
    * `public int hashCode()`：返回每个对象的 hash 值



# 8. 理解 main 方法的语法

* 由于 JVM 需要调用类的 main()方法，所以该方法的访问权限必须是 public
* 又因为 JVM 在执行 main()方法时不必创建对象，所以该方法必须是 static 的
* 该方法接收一个 String 类型的数组参数，该数组中保存执行 Java 命令时传递给所运行的类的参数
* 又因为 main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况